---
- name: F
  hosts: nebula_nodes 

  vars: 
    work_dir: /tmp/yeltnar-ansible
    nebula_ca_name: "yeltnar nebula ca"
    nebula_config_client_folder: "/etc/nebula/"
    # executable_dir # is found in vars/{os_type}/{processor_arch}
  
  # TODO make sure jq is installed
  # TODO make sure BECOME password is used 

  vars_files:
    - nebula-config.yml
    - vars/{{ansible_facts.system}}/{{ansible_facts.machine}}.yml
    - vars/orchestrator.yml # this needs to be changed to reflect the OS ansible is being ran on 
 
  tasks:

    # - name: Print all available facts
    #   ansible.builtin.debug:
    #     var: ansible_facts

    # - name: write facts
    #   local_action:
    #     module: shell
    #   # shell:
    #   # sed -i s/4.20/4.x/ package.json
    #     # vars_files: 
    #     #   - vars/{{ansible_local.system}}/{{ansible_local.machine}}.yml
    #     cmd: | 
    #       echo "{{hostvars}}"  > /tmp/ansible_local.json ; 
    
    # - meta: end_play

    # install download binaries 
    - name: download binaries to orchestrator machine 
      local_action:
        module: shell
        cmd: |
          version=$(curl https://api.github.com/repos/slackhq/nebula/releases/latest | jq -r .tag_name)
          
          mkdir -p "{{work_dir}}_orch"
          rm -rf {{work_dir}}_orch/*
          cd "{{work_dir}}_orch"
          
          curl -OL "https://github.com/slackhq/nebula/releases/download/$version/{{orchestrator_os_file_name}}"

          echo "$version\n{{orchestrator_os_file_name}}\n{{work_dir}}\n$PWD" > /tmp/drew_ansible.log

          extract {{orchestrator_os_file_name}}
        #creates: "/dev/nulll"
      run_once: true
      register: binaries_log

    # download binaries to client machines 
    - name: download binaries to client machines
      shell:
        executable: /bin/bash
        cmd: |

          version=$(curl https://api.github.com/repos/slackhq/nebula/releases/latest | jq -r .tag_name)
          
          mkdir -p {{work_dir}}
          rm -rf {{work_dir}}/*
          cd {{work_dir}}
          
          curl -OL "https://github.com/slackhq/nebula/releases/download/$version/{{os_file_name}}"

          ~/playin/custom_bashrc/bin/extract {{os_file_name}} # TODO need to be more dynamic

    - name: move binaries to bin dir (as root)
      shell:
        cmd : |
          cd {{work_dir}}
          mv nebula {{executable_dir}}/
          mv nebula-cert {{executable_dir}}/
          cd .. && rm -rf {{work_dir}}
      become: true

    # TODO maybe dont if it exists, or download from bitwarden  
    - name: create nebula ca 
      local_action:
        module: shell
        cmd: |
          cd "{{work_dir}}_orch"
          ./nebula-cert ca -name "{{nebula_ca_name}}"
        creates: "{{work_dir}}/ca.crt"
      run_once: true

    - name: create nebula certs
      local_action:
        module: shell
        cmd: |
          cd "{{work_dir}}_orch"
          mkdir -p "{{item.value.name}}"

          ./nebula-cert sign \
          -out-crt {{item.value.name}}/host.crt -out-key {{item.value.name}}/host.key \
          -name "{{item.value.name}}" \
          -ip "{{item.value.nebula_ip}}" \
          -groups "{item.value.signed_groups}" 
      loop: "{{hostvars | dict2items}}"
      run_once: true

    # TODO upload certs to bitwarden; this should allow for communication assuming the overlay network is down 
    
    # create the config.yml for each host 
    - name: create config for hosts
      local_action: 
        module: template
        src: ./template/config.yml.j2
        dest: "{{work_dir}}_orch/{{ liiiiit.value.name }}/config.yml"
      vars:
        lighthouse: 
          am_lighthouse: "{{ liiiiit.value.am_lighthouse }}"
      loop: "{{hostvars | dict2items}}"
      loop_control:
        loop_var: liiiiit
      run_once: true

    - name: make sure nebula directory exists
      file: 
        path: /etc/nebula/inputfiles
        state: directory
      become: true

    # TODO make some logic to allow for multiple certs, therefore allowing for multiple iterations of the network

    # TODO backup current cert and keys (the config may not change?)

    # backup last added /etc/nebula/ca.crt
    - name: move files so network has some time to come up with new files
      copy: 
        backup: false
        dest: "/etc/nebula/inputfiles/ansible.{{ item }}.old"
        src: "/etc/nebula/inputfiles/ansible.{{ item }}.new"
        remote_src: true
      become: true
      ignore_errors: yes
      with_items: 
        - ca.crt

    # copy newly created crt and key to /etc/nebula/host.crt, /etc/nebula/host.key
    - name: copy client crt, key to clients
      copy: 
        backup: false
        dest: "/etc/nebula/{{ item }}"
        # src: "{{work_dir}}/{{hostvars[host].nebula_name}}/{{ item }}"
        src: "{{work_dir}}_orch/{{ hostvars[inventory_hostname].nebula_name }}/{{ item }}"
      become: true
      with_items: 
        - host.crt
        - host.key

    # copy newly created ca.crt to /etc/nebula/host.crt, /etc/nebula/host.key
    - name: copy ca.crt file to clients
      copy: 
        backup: false
        dest: "/etc/nebula/inputfiles/ansible.{{ item }}.new"
        # src: "{{work_dir}}/{{hostvars[host].nebula_name}}/{{ item }}"
        src: "{{work_dir}}_orch/{{ item }}"
      become: true
      with_items: 
        - ca.crt

    # TODO join the ca.cert into one file to be used by the config
    - name: join the ca.crt files to be used by the config
      shell:
        cmd: | 
          cd "{{nebula_config_client_folder}}"

          out_file="{{nebula_config_client_folder}}/{{item}}"

          printf "" > "$out_file" # clear the current file

          ls inputfiles | awk '/{{item}}/{print "cat inputfiles/" $1 " >> {{item}}"}' | bash

        executable: /bin/bash
      become: true 
      with_items:
        - ca.crt

    # copy to /etc/nebula/config.yml
    - name: copy client config file to clients
      copy: 
        backup: false
        dest: "/etc/nebula/{{ item }}"
        # src: "{{work_dir}}/{{hostvars[host].nebula_name}}/{{ item }}"
        src: "{{work_dir}}_orch/{{ hostvars[inventory_hostname].nebula_name }}/{{ item }}"
      become: true
      with_items: 
        - config.yml

    # create the systemd service 
    - name: create systemd service
      copy: 
        backup: false
        dest: "/etc/systemd/system/nebula.service"
        src: "nebula.service"
      become: true

    # - name: restart the nebula service
    #   systemd: 
    #     name: nebula 
    #     state: restarted
    #     enabled: true
    #     no_block: true
    #   become: true

    # script to restart nebula daemon cuz it breaks the ssh connection 
    - name: manually restart the nebula service
      become: true
      shell: |
        sleep 60 && systemctl restart nebula.service & echo 100

- name: upload cert
  hosts: do.andbrant.com

  vars: 
    work_dir: /tmp/yeltnar-ansible

  tasks: 
    - name: "upload cert"
      copy:  
        backup: false
        dest: "~/playin/caddy-cloud/hot/ca.crt"
        src: "{{work_dir}}_orch/ca.crt"
  

